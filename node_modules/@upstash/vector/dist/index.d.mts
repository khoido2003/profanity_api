type CacheSetting = "default" | "force-cache" | "no-cache" | "no-store" | "only-if-cached" | "reload" | false;
type UpstashRequest = {
    path?: string[];
    /**
     * Request body will be serialized to json
     */
    body?: unknown;
};
type UpstashResponse<TResult> = {
    result?: TResult;
    error?: string;
};
interface Requester {
    request: <TResult = unknown>(req: UpstashRequest) => Promise<UpstashResponse<TResult>>;
}
type RetryConfig = false | {
    /**
     * The number of retries to attempt before giving up.
     *
     * @default 5
     */
    retries?: number;
    /**
     * A backoff function receives the current retry cound and returns a number in milliseconds to wait before retrying.
     *
     * @default
     * ```ts
     * Math.exp(retryCount) * 50
     * ```
     */
    backoff?: (retryCount: number) => number;
};
type RequesterConfig = {
    /**
     * Configure the retry behaviour in case of network errors
     */
    retry?: RetryConfig;
    /**
     * Configure the cache behaviour
     * @default "no-store"
     */
    cache?: CacheSetting;
};

declare const ENDPOINTS: readonly ["upsert", "query", "delete", "fetch", "reset", "range", "info", "upsert-data", "query-data"];
type EndpointVariants = (typeof ENDPOINTS)[number];
/**
 * TResult is the raw data returned from upstash, which may need to be transformed or parsed.
 */
declare class Command<TResult> {
    readonly payload: Record<string, unknown> | unknown[];
    readonly endpoint: EndpointVariants;
    constructor(command: Record<string, unknown> | unknown[], endpoint: EndpointVariants);
    /**
     * Execute the command using a client.
     */
    exec(client: Requester): Promise<TResult>;
}

declare class DeleteCommand extends Command<{
    deleted: number;
}> {
    constructor(id: (number[] | string[]) | number | string);
}

type Vector<TMetadata = Record<string, unknown>> = {
    id: string;
    vector: number[];
    metadata?: TMetadata;
};

type FetchResult<TMetadata = Record<string, unknown>> = Vector<TMetadata> | null;

type QueryCommandPayload = {
    topK: number;
    filter?: string;
    includeVectors?: boolean;
    includeMetadata?: boolean;
} & ({
    vector: number[];
    data?: never;
} | {
    data: string;
    vector?: never;
});
type QueryResult<TMetadata = Record<string, unknown>> = {
    id: number | string;
    score: number;
    vector: number[];
    metadata?: TMetadata;
};
declare class QueryCommand<TMetadata> extends Command<QueryResult<TMetadata>[]> {
    constructor(payload: QueryCommandPayload);
}

type RangeCommandPayload = {
    cursor: number | string;
    limit: number;
    includeVectors?: boolean;
    includeMetadata?: boolean;
};
type RangeResult<TMetadata = Record<string, unknown>> = {
    nextCursor: string;
    vectors: Vector<TMetadata>[];
};
declare class RangeCommand<TMetadata> extends Command<RangeResult<TMetadata>> {
    constructor(payload: RangeCommandPayload);
}

type InfoResult = {
    vectorCount: number;
    pendingVectorCount: number;
    indexSize: number;
    dimension: number;
    similarityFunction: "COSINE" | "EUCLIDEAN" | "DOT_PRODUCT";
};

type CommandArgs<TCommand extends new (_args: any) => any> = ConstructorParameters<TCommand>[0];
/**
 * Serverless vector client for upstash vector db.
 */
declare class Index$1<TIndexMetadata extends Record<string, unknown> = Record<string, unknown>> {
    protected client: Requester;
    /**
     * Create a new vector db client
     *
     * @example
     * ```typescript
     * const index = new Index({
     *  url: "<UPSTASH_VECTOR_REST_URL>",
     *  token: "<UPSTASH_VECTOR_REST_TOKEN>",
     * });
     * ```
     */
    constructor(client: Requester);
    /**
     * Deletes a specific item or items from the index by their ID(s).   *
     *
     * @example
     * ```js
     * await index.delete('test-id')
     * ```
     *
     * @param id - List of ids or single id
     * @returns A promise that resolves when the request to delete the index is completed.
     */
    delete: (args: CommandArgs<typeof DeleteCommand>) => Promise<{
        deleted: number;
    }>;
    /**
     * Queries an index with specified parameters.
     * This method creates and executes a query command on an index based on the provided arguments.
     *
     * @example
     * ```js
     * await index.query({
     *  topK: 3,
     *  vector: [ 0.22, 0.66 ],
     *  filter: "age >= 23 and (type = \'turtle\' OR type = \'cat\')"
     * });
     * ```
     *
     * @param {Object} args - The arguments for the query command.
     * @param {number[]} args.vector - An array of numbers representing the feature vector for the query.
     *                                This vector is utilized to find the most relevant items in the index.
     * @param {number} args.topK - The desired number of top results to be returned, based on relevance or similarity to the query vector.
     * @param {string} [args.filter] - An optional filter string to be used in the query. The filter string is used to narrow down the query results.
     * @param {boolean} [args.includeVectors=false] - When set to true, includes the feature vectors of the returned items in the response.
     * @param {boolean} [args.includeMetadata=false] - When set to true, includes additional metadata of the returned items in the response.
     *
     * @returns A promise that resolves with an array of query result objects when the request to query the index is completed.
     */
    query: <TMetadata extends Record<string, unknown> = TIndexMetadata>(args: CommandArgs<typeof QueryCommand>) => Promise<QueryResult<TMetadata>[]>;
    /**
     * Upserts (Updates and Inserts) specific items into the index.
     * It's used for adding new items to the index or updating existing ones.
     *
     * @example
     * ```js
     * const upsertArgs = {
     *   id: '123',
     *   vector: [0.42, 0.87, ...],
     *   metadata: { property1: 'value1', property2: 'value2' }
     * };
     * const upsertResult = await index.upsert(upsertArgs);
     * console.log(upsertResult); // Outputs the result of the upsert operation
     * ```
     *
     * @param {CommandArgs<typeof UpsertCommand>} args - The arguments for the upsert command.
     * @param {number|string} args.id - The unique identifier for the item being upserted.
     * @param {number[]} args.vector - The feature vector associated with the item.
     * @param {Record<string, unknown>} [args.metadata] - Optional metadata to be associated with the item.
     *
     * @returns {string} A promise that resolves with the result of the upsert operation after the command is executed.
     */
    upsert: <TMetadata extends Record<string, unknown> = TIndexMetadata>(args: {
        id: string | number;
        vector: number[];
        metadata?: (TMetadata extends infer U ? U : never) | undefined;
    } | {
        id: string | number;
        data: string;
        metadata?: (TMetadata extends infer U ? U : never) | undefined;
    } | ({
        id: string | number;
        vector: number[];
        metadata?: (TMetadata extends infer U ? U : never) | undefined;
    }[] | {
        id: string | number;
        data: string;
        metadata?: (TMetadata extends infer U ? U : never) | undefined;
    }[])) => Promise<string>;
    /**
     * It's used for retrieving specific items from the index, optionally including
     * their metadata and feature vectors.
     *
     * @example
     * ```js
     * const fetchIds = ['123', '456'];
     * const fetchOptions = { includeMetadata: true, includeVectors: false };
     * const fetchResults = await index.fetch(fetchIds, fetchOptions);
     * console.log(fetchResults); // Outputs the fetched items
     * ```
     *
     * @param {...CommandArgs<typeof FetchCommand>} args - The arguments for the fetch command.
     * @param {(number[]|string[])} args[0] - An array of IDs of the items to be fetched.
     * @param {FetchCommandOptions} args[1] - Options for the fetch operation.
     * @param {boolean} [args[1].includeMetadata=false] - Optionally include metadata of the fetched items.
     * @param {boolean} [args[1].includeVectors=false] - Optionally include feature vectors of the fetched items.
     *
     * @returns {Promise<FetchReturnResponse<TMetadata>[]>} A promise that resolves with an array of fetched items or null if not found, after the command is executed.
     */
    fetch: <TMetadata extends Record<string, unknown> = TIndexMetadata>(ids: number[] | string[], opts?: {
        includeMetadata?: boolean | undefined;
        includeVectors?: boolean | undefined;
    } | undefined) => Promise<FetchResult<TMetadata>[]>;
    /**
     * It's used for wiping an entire index.
     *
     * @example
     * ```js
     * await index.reset();
     * console.log('Index has been reset');
     * ```
     *
     * @returns {Promise<string>} A promise that resolves with the result of the reset operation after the command is executed.
     */
    reset: () => Promise<string>;
    /**
     * Retrieves a range of items from the index.
     *
     * @example
     * ```js
     * const rangeArgs = {
     *   cursor: 0,
     *   limit: 10,
     *   includeVectors: true,
     *   includeMetadata: false
     * };
     * const rangeResults = await index.range(rangeArgs);
     * console.log(rangeResults); // Outputs the result of the range operation
     * ```
     *
     * @param {CommandArgs<typeof RangeCommand>} args - The arguments for the range command.
     * @param {number|string} args.cursor - The starting point (cursor) for the range query.
     * @param {number} args.limit - The maximum number of items to return in this range.
     * @param {boolean} [args.includeVectors=false] - Optionally include the feature vectors of the items in the response.
     * @param {boolean} [args.includeMetadata=false] - Optionally include additional metadata of the items in the response.
     *
     * @returns {Promise<RangeReturnResponse<TMetadata>>} A promise that resolves with the response containing the next cursor and an array of vectors, after the command is executed.
     */
    range: <TMetadata extends Record<string, unknown> = TIndexMetadata>(args: CommandArgs<typeof RangeCommand>) => Promise<RangeResult<TMetadata>>;
    /**
     * Retrieves info from the index.
     *
     * @example
     * ```js
     * const infoResults = await index.info();
     * console.log(infoResults); // Outputs the result of the info operation
     * ```
     *
     * @returns {Promise<InfoResult>} A promise that resolves with the response containing the vectorCount, pendingVectorCount, indexSize, dimension count and similarity algorithm after the command is executed.
     */
    info: () => Promise<InfoResult>;
}

/**
 * Connection credentials for upstash vector.
 * Get them from https://console.upstash.com/vector/<uuid>
 */
type IndexConfig = {
    /**
     * UPSTASH_VECTOR_REST_URL
     */
    url?: string;
    /**
     * UPSTASH_VECTOR_REST_TOKEN
     */
    token?: string;
    /**
     * The signal will allow aborting requests on the fly.
     * For more check: https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal
     */
    signal?: AbortSignal;
} & RequesterConfig;
/**
 * Serverless vector client for upstash.
 */
declare class Index<TIndexMetadata extends Record<string, unknown> = Record<string, unknown>> extends Index$1<TIndexMetadata> {
    /**
     * Create a new vector client by providing the url and token
     *
     * @example
     * ```typescript
     * const index = new Index({
     *  url: "<UPSTASH_VECTOR_REST_URL>",
     *  token: "<UPSTASH_VECTOR_REST_TOKEN>",
     * });
     * ```
     * OR
     * This will automatically get environment variables from .env file
     * ```typescript
     * const index = new Index();
     * ```
     */
    constructor(config?: IndexConfig);
    /**
     * Create a new vector client by providing a custom `Requester` implementation
     *
     * @example
     * ```ts
     *
     * import { UpstashRequest, Requester, UpstashResponse, vector } from "@upstash/vector"
     *
     *  const requester: Requester = {
     *    request: <TResult>(req: UpstashRequest): Promise<UpstashResponse<TResult>> => {
     *      // ...
     *    }
     *  }
     *
     * const vector = new vector(requester)
     * ```
     */
    constructor(requesters?: Requester);
    /**
     * Create a new Upstash Vector instance from environment variables.
     *
     * Use this to automatically load connection secrets from your environment
     * variables. For instance when using the Vercel integration.
     *
     * This tries to load `UPSTASH_VECTOR_REST_URL` and `UPSTASH_VECTOR_REST_TOKEN` from
     * your environment using `process.env`.
     */
    static fromEnv(config?: Omit<IndexConfig, "url" | "token">): Index;
}

export { type FetchResult, Index, type IndexConfig, type InfoResult, type QueryResult, type RangeResult, type Requester, type UpstashRequest, type UpstashResponse, type Vector };
